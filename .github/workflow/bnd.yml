name: Back Up and Update
on:
  # Manual triggering from the GitHub Actions tab
  # 1. Download the active version of the object from CPI PRD - TBD
  # 2. Store the downloaded file to repo Archive folder
  # 3. Download the active version of the object from CPI Non-PRD
  # 4. Extract the downloaded file to repo workspace
  workflow_dispatch:
    inputs:
      iflow_id:
        description: 'The technical ID of the iFlow to download (e.g., MyFlowID)'
        required: true
        default: 'YOUR_IFLOW_ID' # Replace with a sensible default
        
permissions:
  contents: write
  
env:
  # Directory where the extracted iFlow content will be placed
  IFLOW_DIR: Archive
  # Set the technical ID from the workflow input
  IFLOW_ID: ${{ github.event.inputs.iflow_id }}

jobs:
  sync_iflow:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # --- CPI Download and Extraction ---
      - name: Clean Input String
        run: |   
          # Clean Input String
          INPUT_STRING="${{ env.IFLOW_ID }}"
          CLEANED_STRING=$( echo "${INPUT_STRING}" | tr -d '-' )
          ${{ env.IFLOW_ID }}=${CLEANED_STRING}          
          echo "Original String: ${INPUT_STRING}"
          echo "Cleaned String: ${CLEANED_STRING}"
          echo "New IFLOW ID: ${{ env.IFLOW_ID }}"

          
      - name: Create Artifact Directory for Archive
        run: |
          # Create Artifact Archive directory         
          mkdir -p ${{ env.IFLOW_DIR }}/${CLEANED_STRING}

          # Create a temporary file path for the downloaded ZIP
          echo "ZIP_PATH=${{ runner.temp }}/${CLEANED_STRING}.zip" >> $GITHUB_ENV
          #echo "ZIP_PATH=${{ runner.temp }}/${{ env.IFLOW_ID }}.zip" >> $GITHUB_ENV
          
      - name: Get Bearer Token
        run: |
          # Get Bearer Token
          TOKEN=$(curl -s GET "${{ secrets.TOKEN_URL }}?grant_type=client_credentials" \
                  -H "Content-Type: application/json" \
                  -H "Authorization: Basic ${{ secrets.CPI_BASIC64 }}" | \
                  #-d "{\"client_id\":\"${{ secrets.CLIENT_ID }}\", \"client_secret\":\"${{ secrets.CLIENT_SECRET }}\", \"grant_type\":\"client_credentials\"}"
                  #-d "{\"client_id\":\"${{ secrets.CLIENT_ID }}\", \"client_secret\":\"${{ secrets.CLIENT_SECRET }}\", \"grant_type\":\"client_credentials\"}" | \
                  jq -r '.access_token'
                  )
           echo "${TOKEN}"
           echo "BEARER_TOKEN=${TOKEN}" >> $GITHUB_ENV   
           
      - name: Download iFlow Package ZIP from CPI
        run: |                  
          # The CPI OData API endpoint for downloading the artifact content (the ZIP file)
          # Note: We use the 'active' version, which corresponds to the currently deployed version.
          CPI_API_ENDPOINT="${{ secrets.CPI_BASE_URL }}/api/v1/IntegrationDesigntimeArtifacts(Id='${{ env.IFLOW_ID }}',Version='active')/\$value"

          echo "Attempting to download from: ${CPI_API_ENDPOINT}"

          # Use curl to download the ZIP, passing credentials via basic authentication
          #curl -L -u "${{ secrets.CPI_USER }}:${{ secrets.CPI_PASSWORD }}" \
          #  -o "${{ env.ZIP_PATH }}" \
          #  "${CPI_API_ENDPOINT}"
          curl -f -L \
            -H "Authorization: Bearer ${{ env.BEARER_TOKEN }}" \
            -o "${{ env.ZIP_PATH }}" \
            "${CPI_API_ENDPOINT}"
          dir "${{ env.ZIP_PATH }}"
          # Check if the downloaded file size is reasonable (to catch auth errors or 404s)
          FILE_SIZE=$(stat -c%s "${{ env.ZIP_PATH }}")
          #if [ "$FILE_SIZE" -lt 100 ]; then
          #  echo "::error::Downloaded file size is too small ($FILE_SIZE bytes). Check CPI credentials, base URL, and iFlow ID."
          #  exit 1
          #fi

          #mv ${{ env.ZIP_PATH }} ${{ env.IFLOW_DIR }}/${{ env.IFLOW_ID }}

          #dir ${{ env.IFLOW_DIR }}/${{ env.IFLOW_ID }}
          
          FILE_PATH="${{ env.ZIP_PATH }}"
    
          echo "--- File Exists and Size ---"
          ls -l "$FILE_PATH"

          echo "--- File Type Check (should say 'Zip archive data') ---"
          file "$FILE_PATH"
    
          echo "--- Attempt to test the archive (not extract) ---"
          # The -t flag attempts to test the archive integrity without extracting
          unzip -t "$FILE_PATH"
          
        env:
          # Ensure sensitive credentials are only available for this step
          CPI_BASE_URL: ${{ secrets.CPI_BASE_URL }}
          CPI_USER: ${{ secrets.CPI_USER }}
          CPI_PASSWORD: ${{ secrets.CPI_PASSWORD }}

      - name: Extract Contents and Clean Up
        run: |
          # Remove existing files in the target directory to ensure a clean sync
          rm -rf ${{ env.IFLOW_DIR }}/${{ env.IFLOW_ID }}/*

          dir ${{ runner.temp }}/

          # Extract the contents of the downloaded ZIP into the target directory
          # The -o flag overwrites files silently, and -d sets the destination directory
          unzip -o ${{ env.ZIP_PATH }} -d ${{ env.IFLOW_DIR }}/${{ env.IFLOW_ID }}
          
          echo "Extraction complete. Contents, including MANIFEST.MF, are in ${{ env.IFLOW_DIR }}/${{ env.IFLOW_ID }}"

      # --- Git Commit and Push ---

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

      - name: Commit and Push Changes
        run: |
          # Stage all changes in the iFlow directory
          git add ${{ env.IFLOW_DIR }}/${{ env.IFLOW_ID }}

          # Check if there are any changes to commit
          if git diff --cached --exit-code; then
            echo "No changes detected in iFlow ${{ env.IFLOW_ID }}. Skipping commit."
          else
            # Commit the changes
            git commit -m "ðŸ¤– Sync: Update iFlow ${{ env.IFLOW_ID }} from CPI OData API"
            
            # Push the changes back to the default branch
            git push
            echo "Successfully committed and pushed changes for iFlow ${{ env.IFLOW_ID }}."
          fi
